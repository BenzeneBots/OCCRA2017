#pragma config(Sensor, in2,    userPot1,       sensorPotentiometer)
#pragma config(Sensor, dgtl1,  clawClose,      sensorDigitalOut)
#pragma config(Sensor, dgtl6,  armIn,          sensorDigitalOut)
#pragma config(Sensor, dgtl7,  armOut,         sensorDigitalOut)
#pragma config(Sensor, dgtl8,  ledBeacon,      sensorDigitalOut)
#pragma config(Motor,  port2,           LDrive1,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           LDrive2,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           RDrive1,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           RDrive2,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           Intake,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           BallBatter,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           Intake2,       tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// ============================================================================
//	OCCRA Trash Can Rush	Fall 2017 Season
//
//	Last Updated 11/4/2017
//
// ============================================================================

bool prevButtonState = false;
bool reverse = true;
bool clawActive = false;
//long tmVal = 0;
//int leftSmooth=0, rightSmooth=0;
int ledVal=0, ledDir=0;
long tmLED=0;

// Macros ---------------------------------------------------------------------

#define MOTOR_MAX_VALUE			127
#define MOTOR_MIN_VALUE			(-127)

#define LIGHT_LED 				127
#define LIGHT_ORANGE 			(-127)
#define LIGHT_OFF 				0

#define max( A, B )				A > B ? A : B
#define min( A, B )				A < B ? A : B
#define LimitVal( L, T, H )		max( min( T, H ), L)

#define SP_MULT		1.00	// Speed Step-Down Multiplier (for training)
#define STEP		2		// Motor counts to step.
#define TM_STEP		20		// Time (in milliseconds) between steps.
#define TURN_CAL	0.977	// Calibration multiplier applied to right side of drive-train.
#define SP_INTAKE	96		// Intake motor speed (out of a range of 0 to 127).
#define SP_INTAKE_2 57		// Intake motor speed for 2nd motor
#define SP_BATTER	-127	// Ball Batter arm deploy motor speed.
#define ARM_FWD_SP	35		// Robot forward speed while arm is deployed. 70 if in training mode, 35 if in not

//=============================================================================
task main () {
	int joy_x, joy_y;		// Local joystick values read form system values.
	int leftRaw, rightRaw;	// Raw is used to calculate a desired speed.

	wait1Msec( 400 );		// Startup delay before entering the infinite loop.

	while( true ) {

		// Flip Sense of "front" of the robot.
		// --------------------------------------------------------------------------
		if ( vexRT[Btn6U] ) {
			if ( prevButtonState == false ) {
				prevButtonState = true;
				reverse = !reverse;
			}
		}
		else {
			prevButtonState = false;
		}


		// Motor Drive - Arcade
		// --------------------------------------------------------------------------
		joy_x = vexRT[Ch1];		// Get current joystick values.
		joy_y = vexRT[Ch3];

		leftRaw = 0;
		rightRaw = 0;

		if ( reverse ) {			// Reverse sense of "front" of robot.
			leftRaw =  LimitVal( MOTOR_MIN_VALUE, (((joy_x + joy_y))), MOTOR_MAX_VALUE );
			rightRaw = LimitVal( MOTOR_MIN_VALUE, (((joy_x - joy_y))), MOTOR_MAX_VALUE );
			SensorValue[ledBeacon] = 1;
		}
		else {						// Else, use "normal" sense of front of robot.
			leftRaw =  LimitVal( MOTOR_MIN_VALUE, (((joy_x - joy_y))), MOTOR_MAX_VALUE );
			rightRaw = LimitVal( MOTOR_MIN_VALUE, (((joy_x + joy_y))), MOTOR_MAX_VALUE );
			SensorValue[ledBeacon] = 0;
		}
	/*
		// acceleration tuning
		if( tmVal < time1[ timer1 ] ) {
			tmVal = time1[timer1] + TM_STEP;					// ReSchedule for future.

			if( leftSmooth < leftRaw ) leftSmooth += STEP;
			else if( leftSmooth > leftRaw ) leftSmooth -= STEP;
			else leftSmooth = leftRaw;

			if( rightSmooth < rightRaw ) rightSmooth += STEP;
			else if( rightSmooth > rightRaw ) rightSmooth -= STEP;
			else rightSmooth = rightRaw;
		}
		*/

		// On batter arm deployed, add some motor speed.
		if( vexRT[Btn7L] ) {
			leftRaw = LimitVal( MOTOR_MIN_VALUE, leftRaw + ARM_FWD_SP, MOTOR_MAX_VALUE );
			rightRaw = LimitVal( MOTOR_MIN_VALUE, rightRaw - ARM_FWD_SP, MOTOR_MAX_VALUE );
		}

		motor[LDrive1] = (int)(leftRaw * SP_MULT);
		motor[LDrive2] =  (int)(leftRaw * SP_MULT);

		motor[RDrive1] =  (int)(TURN_CAL * rightRaw * SP_MULT);
		motor[RDrive2] =  (int)(TURN_CAL * rightRaw * SP_MULT);


		// Throb the LED strips up and down in an intensity, just for fun.
		// --------------------------------------------------------------------------
		/*
		if( tmLED < time1[timer1] ) {
			tmLED = time1[timer1] + 25;						// ReExecute every 25ms.

			if( (ledVal < 124) &&  ledDir ) ledVal += 4;	// Make sure numbers are divisible by step value.
			if( (ledVal > -48)   && !ledDir ) ledVal -= 4;

			if( ledVal == 124 ) ledDir = 0;					// Switch direction at the top end.
			if( ledVal == -48 ) ledDir = 1;					// Run negative to keep the LEDs off for a bit.

			motor[ ledStrips ] = ledVal;					// Finally, send the value to the motor controller.
		}
		*/
		// Pneumatic Control for Batter Arm Deploy
		// --------------------------------------------------------------------------
		if( vexRT[Btn8UXmtr2] ) {
			SensorValue[armOut] = 1;			// Deploy Arm
			SensorValue[armIn] = 0;
			motor[BallBatter] = SP_BATTER;		// Start Motor
		}
		else {
			SensorValue[armOut] = 0;			// Retract Arm
			SensorValue[armIn] = 1;
			motor[BallBatter] = 0;				// Stop Motor
		}


		// Pneumatic System Output Control for Claw
		// --------------------------------------------------------------------------
		if ( vexRT[Btn6UXmtr2] ) {
			SensorValue[clawClose] = 0;
			clawActive = false;
		}
		if ( vexRT[Btn6DXmtr2] ) {
			SensorValue[clawClose] = 1;
			clawActive = true;
		}

		/*
		// LED Strip on Claw Control
		// --------------------------------------------------------------------------
		//use pot value for testing
		int potValue = LimitVal(-127, SensorValue[sensorPotentiometer]/32, 127);
		if( clawActive ) {
			motor[ledStrips] = potValue;
		}
		else{
			motor[ledStrips] = 0;
		}
		*/

		/*if( clawActive ) {
		if( tmVal < time1[ timer1 ] ) {
		tmVal = time1[timer1] + 500;		// ReSchedule time value into the future.
		if( SensorValue[ ledCLAW ] )		// If the LEDs are on, turn them off.
		SensorValue[ ledCLAW ] = 0;
		else														// Else, turn them on.
		SensorValue[ ledCLAW ] = 1;
		}
		}
		else {															// Init LEDs and timer when claw is off.
		SensorValue[ ledCLAW ] = 0;
		tmVal = 0;
		}
		*/

		// Intake Motor
		// --------------------------------------------------------------------------
		if ( vexRT[Btn5UXmtr2] ) {
			motor[Intake] = -SP_INTAKE;
			motor[Intake2] = -SP_INTAKE_2;
		}
		else if ( vexRT[Btn5DXmtr2] ) {
			motor[Intake] = SP_INTAKE;
			motor[Intake] = SP_INTAKE_2;
		}
		else {
			motor[Intake] = 0;
			motor[Intake2] = 0;
		}

		/*
		// Ball Batter Arm
		// --------------------------------------------------------------------------
		if ( vexRT[Btn8UXmtr2] ){
			motor[BallBatter] = SP_BATTER;
		}
		else if ( vexRT[Btn8DXmtr2] ){
			motor[BallBatter] = -SP_BATTER;
		}
		else if ( abs(vexRT[Ch3Xmtr2]) > 5 ) {		// Else, use joystick if not in dead zone.
			motor[BallBatter] = vexRT[Ch3Xmtr2];	// Simply copy joystick value to motor.
		}
		else{
			motor[BallBatter] = 0;					// Else, set motor to zero speed.
		}
		*/
	} // while
} // main
