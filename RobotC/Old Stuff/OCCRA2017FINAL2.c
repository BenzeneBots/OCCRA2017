#pragma config(Sensor, dgtl1,  PSIOUT1,        sensorDigitalOut)
#pragma config(Sensor, dgtl6,  ledFWD,         sensorDigitalOut)
#pragma config(Sensor, dgtl7,  ledREV,         sensorDigitalOut)
#pragma config(Motor,  port2,           LDrive1,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           LDrive2,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           RDrive1,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           RDrive2,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           Intake,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           BallBatter,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           SigLight,      tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool prevButtonState = false;
bool reverse = true;

// Macros ---------------------------------------------------------------------

#define MOTOR_MAX_VALUE			127
#define MOTOR_MIN_VALUE			(-127)
#define SCALE_DEGREE				1.5

#define LIGHT_LED 					127
#define LIGHT_ORANGE 				(-127)
#define LIGHT_OFF 					0

#define max( A, B )				A > B ? A : B
#define min( A, B )				A < B ? A : B
#define LimitVal( L, T, H )		max( min( T, H ), L)
float scaleInput(float value, float degree);

//=============================================================================
task main () {

	wait1Msec(400);

	while (true) {

		// Flip Functionality
		// --------------------------------------------------------------------------
		if (vexRT[Btn6U]) {
			if (prevButtonState == false) {
				prevButtonState = true;
				reverse = !reverse;
			}
		}
		else {
			prevButtonState = false;
		}
		// Scaling factor for flip


		//Motor Drive - Arcade
		// --------------------------------------------------------------------------
		int joy_x = vexRT[Ch1];
		int joy_y = vexRT[Ch3];

		int leftVal = 0;
		int rightVal = 0;
		float floatRightVal = 0.0;
		float scaledRightVal = 0.0;
		float floatLeftVal = 0.0;
		float scaledLeftVal = 0.0;

		if (reverse) {
			leftVal = LimitVal(MOTOR_MIN_VALUE, (((joy_x + joy_y)/2)), MOTOR_MAX_VALUE);
			floatLeftVal = 1.0 * leftVal;
			scaledLeftVal = scaleInput(floatLeftVal, SCALE_DEGREE);

			rightVal = LimitVal(MOTOR_MIN_VALUE, (((joy_x - joy_y)/2)), MOTOR_MAX_VALUE);
			floatRightVal = 1.0 * rightVal;
			scaledRightVal = scaleInput(floatRightVal, SCALE_DEGREE);

			SensorValue[ledREV] = 1;
			SensorValue[ledFWD] = 0;
		}
		else {
			leftVal = LimitVal( MOTOR_MIN_VALUE , (((joy_x - joy_y)/2)), MOTOR_MAX_VALUE );
			floatLeftVal = 1.0 * leftVal;
			scaledLeftVal = scaleInput(floatLeftVal, SCALE_DEGREE);

			rightVal = LimitVal( MOTOR_MIN_VALUE    , (((joy_x + joy_y)/2)), MOTOR_MAX_VALUE );
			floatRightVal = 1.0 * rightVal;
			scaledRightVal = scaleInput(floatRightVal, SCALE_DEGREE);

			SensorValue[ledREV] = 0;
			SensorValue[ledFWD] = 1;
		}

		motor[LDrive1] = (int)scaledLeftVal;
		motor[LDrive2] =  (int)scaledLeftVal;

		motor[RDrive1] =  (int)scaledRightVal;
		motor[RDrive2] =  (int)scaledRightVal;


		//Pneumatic System Output Control
		// --------------------------------------------------------------------------
		if (vexRT[Btn6UXmtr2]) {
			SensorValue[PSIOUT1] = 0;
		}
		if (vexRT[Btn6DXmtr2]) {
			SensorValue[PSIOUT1] = 1;
		}//add led output 8

		//Intake Motor
		// --------------------------------------------------------------------------
		if (vexRT[Btn5UXmtr2]) {
			motor[Intake] = -96;
		}
		else if (vexRT[Btn5DXmtr2]) {
			motor[Intake] = 96;
		}
		else {
			motor[Intake] = 0;
		}

		// Ball Batter Arm
		// --------------------------------------------------------------------------
		if (vexRT[Btn8UXmtr2]){
			motor[BallBatter] = 45;
		}
		else if ( vexRT[Btn8DXmtr2] ){
			motor[BallBatter] = -45;
		}
		else if (abs(vexRT[Ch3Xmtr2]) > 5 ){					// On joystick,
			motor[BallBatter] = vexRT[Ch3Xmtr2];
		}
		else{
			motor[BallBatter] = 0;
		}

	} // while
} // main

float scaleInput(float value, float degree){
	float newVal;
	if(value <= 0){
		newVal = (1.0/pow(value, degree - 1))*pow(value, degree);
	}
	else{
		value *= -1.0;
		newVal = -1.0 * (1.0/pow(value, degree - 1))*pow(value, degree);

	}
	return newVal;
}
