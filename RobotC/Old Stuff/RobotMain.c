#pragma config(Sensor, dgtl1,  Shooter_Sp,     sensorRotation)
#pragma config(Motor,  port2,           rightMotor,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           leftMotor,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           shooterMotor,  tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           intakeMotor,   tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port6,           elevatorMotor, tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port7,           m7,            tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           m8,            tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port9,           m9,            tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// ============================================================================
//
// OCCRA Ball Shooting Robot:						Last Update: 10/25/2016
//
//
// ============================================================================

// Function prototypes go here...
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
task MotorSlewRateTask( );
task ShooterSpControl();

// Constants
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
#define INTAKE_SCALE	0.500					// Percent speed to run motor.
#define ELEVATOR_SCALE	0.500

#define MAX_SP			127						// Max Motor Speed
#define FWD				1						// Forward
#define REV				(-1)					// Reverse
#define STOP			0                   	// Motor Stop Speed
#define SHOOTER_SP		( 0.4384 * MAX_SP )		// Scaled Shooter Output Speed.
#define SH_BOOST_PWM	50						// Boost PWM value for shooter.
#define SH_READY		100
#define SH_MOT_IND		3

// Slew Rate Control Values
#define MOTOR_NUM				6		// First six motors get slew rate control.
#define MOTOR_MAX_VALUE			127
#define MOTOR_MIN_VALUE			(-127)
#define MOTOR_DEFAULT_SLEW_RATE	3		// Default will cause 375mS from full fwd to rev
#define MOTOR_TASK_DELAY		25      // Task Rate = 1/frequency in mS (about 66Hz)

// Macros
#define max( A, B )				A > B ? A : B
#define min( A, B )				A < B ? A : B
#define LimitVal( L, T, H)		max( min( T, H ), L)

// Globals
// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

int Shooter_Speed = 0;			// Local Copy of Shooter Speed.
int Shooter_Target = 0;			// Target speed for shooter motor.
int Shooter_PWM = 0;			// Default PWM Output for Shooter.

// Slew rate is the amount the PWM can change per task cycle.
							  // na, Rt, Lt, Sh, In, El
int motorSlewUp[ MOTOR_NUM ] = { 0,  3,  3,  2, 30, 30 };	// Slew Rate Up
int motorSlewDn[ MOTOR_NUM ] = { 0,  3,  3,  2, 30, 30 };	// Slew Rate Down

int mot[ MOTOR_NUM ];			// Array to hold requested speed for the motors.


// ============================================================================
task main () {

	int joy_x, joy_y;
	int Sh_Tmr = 0;

	startTask( MotorSlewRateTask );		// Start motor slew rate control task.
	startTask( ShooterSpControl );		// Task handles controlling the shooter motor.
	wait1Msec( 400 );

	while ( true ) {

		// 1 = Right
		// 2 = Left
		// 3 = Shooter
		// 4 = Intake
		// 5 = Elevator
		// 6 =
		// Drive Code..........................................................
		joy_x = vexRT[Ch1] * -1;	// Grab a copy of the values from the system vars.
		joy_y = vexRT[Ch3];

		// Compute movement based on a foward / reverse knob and a steering knob.
		mot[ leftMotor ]  = LimitVal( -127, (joy_x - joy_y)/2, 127 );
		mot[ rightMotor ] = LimitVal( -127, (joy_x + joy_y)/2, 127 );


		// Intake code.........................................................
		if ( vexRT[ Btn5UXmtr2 ] ) { //If the upper left trigger is pressed
			mot[ intakeMotor ] = INTAKE_SCALE * 127; //set intake motor forward
		}
		else if ( vexRT[Btn5DXmtr2 ] ) {	//If the bottom left trigger is pressed
			mot[ intakeMotor ] = INTAKE_SCALE * -127; //set intake motor reverse
		}
		else {
			mot[ intakeMotor ] = STOP;
		}

		// Elevator............................................................
		if ( vexRT[ Btn6UXmtr2 ] ) {
			//if ( (Sh_Tmr == 0) || (Sh_Tmr > SH_READY) ) {
				mot[ elevatorMotor ] = ELEVATOR_SCALE * 127;
				mot[ intakeMotor ] = INTAKE_SCALE * 127;
			//}
		}
		else if ( vexRT[ Btn6DXmtr2 ] ) {
			mot[ elevatorMotor ] = ELEVATOR_SCALE * -127;
			mot[ intakeMotor ] = INTAKE_SCALE * -127;
		}
		else {
			mot[ elevatorMotor ] = STOP;
			//mot[ intakeMotor ] = STOP;
		}

		// Shooter.............................................................
		// Note, the "ShooterSpControl" task takes care of setting the actual
		// motor speed.  Setting "Shooter_Target" just sets a desired speed.
		if ( vexRT[ Btn8DXmtr2 ] ) {
			Shooter_Target = 17;
			// Advance a timer when the shhoter is running.
			Sh_Tmr += 1;
		}
		else if ( vexRT[ Btn7DXmtr2 ] ) {
			Shooter_Target = -5;
			// Advance a timer when the shhoter is running.
			Sh_Tmr += 1;
		}
		else {
			Shooter_Target = STOP;
			// Reset the timer.
			Sh_Tmr = 0;
		}

		// Give other task(s) time to run too.
		wait1Msec( 20 );
	}
}

// ============================================================================
// Control the shooter speed using a feedback sensor.  The sensor counts two
// counts per revolution. Delta counts are calculated every 100ms.
// ============================================================================
task ShooterSpControl( ) {
	int Sp_Old = SensorValue( Shooter_Sp );
	int offset=0, Sp_Tar_Old=0, dir=1;

	while ( 1 ) {
		// Calculate delta speed every 100ms.
		Shooter_Speed = SensorValue( Shooter_Sp ) - Sp_Old;
		Sp_Old = SensorValue( Shooter_Sp );
		wait1Msec( 100 );

		if ( Shooter_Target == STOP ) {
			// Drive Shooter_PWM to zero five PWM steps at a time.
			if ( Shooter_PWM > 5 )			Shooter_PWM -= 5;
			else if ( Shooter_PWM < -5 )	Shooter_PWM += 5;
			else							Shooter_PWM	= STOP;

			offset = 0;
		}
		else {
			dir = Shooter_Target < 0 ? -1 : 1;

			// If target speed just changed off zero, boost the speed by just
			// forcing the output very large and then waiting a bit for the
			// motor to come up to speed.  Then, go close loop.
			if ( Sp_Tar_Old == STOP ) {
				motor[ shooterMotor ] = SH_BOOST_PWM * dir;
				motor[ shooterMotor ] = 100 * dir;
				wait1Msec( 50 );
				//Shooter_Speed = SensorValue( Shooter_Sp ) - Sp_Old;
				//Sp_Old = SensorValue( Shooter_Sp );
				//wait1Msec( 100 );
			}


			// Adjust motor offset if not on target.
			if ( Shooter_Speed < Shooter_Target )		offset += 1;
			else if ( Shooter_Speed > Shooter_Target )	offset -= 1;

			Shooter_PWM = LimitVal( -127, (SHOOTER_SP + offset) * dir, 127);

			// Keep offset from winding up.
			//offset = Shooter_PWM - SHOOTER_SP;
		}

		Sp_Tar_Old = Shooter_Target;
		motor[ shooterMotor ] = Shooter_PWM;
	}
}


// ============================================================================
//  Task  - Compares the requested speed of each motor to the current speed
//          and increments or decrements to reduce the difference as nexessary
// ============================================================================
task MotorSlewRateTask( ) {

	int motorIndex;
	int motorTmp;

	// Array to hold "slew rate" for the motors, the maximum change every time the task
	// runs checking current mootor speed.
	// int motorSlew[ MOTOR_NUM ];


	// Initialize stuff
	for ( motorIndex=0 ; motorIndex < MOTOR_NUM ; motorIndex++ ) {
		mot[ motorIndex ] = 0;
		//motorSlew[ motorIndex ] = MOTOR_DEFAULT_SLEW_RATE;
	}

	while ( 1 ) {

		// For each motor...
		for ( motorIndex=1 ; motorIndex < MOTOR_NUM ; motorIndex++ ) {

			// So we don't keep accessing the internal storage
			motorTmp = motor[ motorIndex ];

			// Do we need to change the motor value?
			if ( motorTmp != mot[ motorIndex ] ) {

				// Increasing motor value
				if ( mot[ motorIndex ] > motorTmp ) {
					motorTmp += motorSlewUp[ motorIndex ];
					// limit
					if ( motorTmp > mot[ motorIndex ] )
						motorTmp = mot[ motorIndex ];
				}

				// Decreasing motor value
				if ( mot[ motorIndex ] < motorTmp ) {
					motorTmp -= motorSlewDn[motorIndex ];
					// limit
					if ( motorTmp < mot[ motorIndex ] )
						motorTmp = mot[ motorIndex ];
				}

				// Finally, set the actual motor output.
				if ( motorIndex != SH_MOT_IND )
                    motor[motorIndex] = LimitVal( -127, motorTmp, 127 );
			}
		}

		// Let other tasks run too.  Plus, this delay also affects the slew
		// rate of the motors.  Set this wisely.
		wait1Msec( MOTOR_TASK_DELAY );
	}
}
