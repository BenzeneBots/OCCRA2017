#pragma config(Sensor, dgtl1,  PSIOUT1,        sensorDigitalOut)
#pragma config(Sensor, dgtl6,  ledFWD,         sensorDigitalOut)
#pragma config(Sensor, dgtl7,  ledREV,         sensorDigitalOut)
#pragma config(Sensor, dgtl8,  ledCLAW,        sensorNone)
#pragma config(Motor,  port2,           LDrive1,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           LDrive2,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           RDrive1,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           RDrive2,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           Intake,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           BallBatter,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           SigLight,      tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

bool prevButtonState = false;
bool reverse = true;

// Macros ---------------------------------------------------------------------

#define MOTOR_MAX_VALUE			127
#define MOTOR_MIN_VALUE			(-127)

#define LIGHT_LED 					127
#define LIGHT_ORANGE 				(-127)
#define LIGHT_OFF 					0

#define max( A, B )				A > B ? A : B
#define min( A, B )				A < B ? A : B
#define LimitVal( L, T, H )		max( min( T, H ), L)

//=============================================================================
task main () {

	wait1Msec(400);

	while (true) {

		// Flip Functionality
		// --------------------------------------------------------------------------
		if (vexRT[Btn6U]) {
			if (prevButtonState == false) {
				prevButtonState = true;
				reverse = !reverse;
			}
		}
		else {
			prevButtonState = false;
		}
		// Scaling factor for flip


		//Motor Drive - Arcade
		// --------------------------------------------------------------------------
		int joy_x = vexRT[Ch1];
		int joy_y = vexRT[Ch3];

		int leftVal = 0;
		int rightVal = 0;

		if (reverse) {
			leftVal = LimitVal(MOTOR_MIN_VALUE, (((joy_x + joy_y)
			)), MOTOR_MAX_VALUE);
			rightVal = LimitVal(MOTOR_MIN_VALUE, (((joy_x - joy_y))), MOTOR_MAX_VALUE);
			SensorValue[ledREV] = 1;
			SensorValue[ledFWD] = 0;
		}
		else {
			leftVal = LimitVal( MOTOR_MIN_VALUE , (((joy_x - joy_y))), MOTOR_MAX_VALUE );
			rightVal = LimitVal( MOTOR_MIN_VALUE    , (((joy_x + joy_y))), MOTOR_MAX_VALUE );
			SensorValue[ledREV] = 0;
			SensorValue[ledFWD] = 1;
		}

		motor[LDrive1] = leftVal;
		motor[LDrive2] =  leftVal;

		motor[RDrive1] =  (int)(0.977 * rightVal);
		motor[RDrive2] =  (int) (0.977 * rightVal);


		//Pneumatic System Output Control
		// --------------------------------------------------------------------------
		if (vexRT[Btn6UXmtr2]) {
			SensorValue[PSIOUT1] = 0;
			SensorValue[ledCLAW] = 0;
		}
		if (vexRT[Btn6DXmtr2]) {
			SensorValue[PSIOUT1] = 1;
			SensorValue[ledCLAW] = 1;
		}//add led output 8

		//Intake Motor
		// --------------------------------------------------------------------------
		if (vexRT[Btn5UXmtr2]) {
			motor[Intake] = -96;
		}
		else if (vexRT[Btn5DXmtr2]) {
			motor[Intake] = 96;
		}
		else {
			motor[Intake] = 0;
		}

		// Ball Batter Arm
		// --------------------------------------------------------------------------
		if (vexRT[Btn8UXmtr2]){
			motor[BallBatter] = 45;
		}
		else if ( vexRT[Btn8DXmtr2] ){
			motor[BallBatter] = -45;
		}
		else if (abs(vexRT[Ch3Xmtr2]) > 5 ){					// On joystick,
			motor[BallBatter] = vexRT[Ch3Xmtr2];
		}
		else{
			motor[BallBatter] = 0;
		}

	} // while
} // main
