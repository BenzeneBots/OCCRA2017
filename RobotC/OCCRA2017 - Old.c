#pragma config(Sensor, in2,    userPot1,       sensorPotentiometer)
#pragma config(Sensor, dgtl1,  PSIOUT1,        sensorDigitalOut)
#pragma config(Sensor, dgtl6,  ledFWD,         sensorDigitalOut)
#pragma config(Sensor, dgtl7,  ledREV,         sensorDigitalOut)
#pragma config(Sensor, dgtl8,  ledCLAW,        sensorDigitalOut)
#pragma config(Motor,  port2,           LDrive1,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           LDrive2,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           RDrive1,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           RDrive2,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           Intake,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           BallBatter,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           SigLight,      tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// ============================================================================
//	OCCRA Trash Can Rush	Fall 2017 Season
//
//	Last Updated 10/29/2017
//
// ============================================================================

bool prevButtonState = false;
bool reverse = true;
bool clawActive = false;
long tmVal = 0;
int leftSmooth=0, rightSmooth=0;


// Macros ---------------------------------------------------------------------

#define MOTOR_MAX_VALUE			127
#define MOTOR_MIN_VALUE			(-127)

#define LIGHT_LED 				127
#define LIGHT_ORANGE 			(-127)
#define LIGHT_OFF 				0

#define max( A, B )				A > B ? A : B
#define min( A, B )				A < B ? A : B
#define LimitVal( L, T, H )		max( min( T, H ), L)

#define SP_MULT		0.55	// Speed Step-Down Multiplier (for training)
#define STEP		8		// Motor counts to step.
#define TM_STEP		10		// Time (in milliseconds) between steps.
#define TURN_CAL	0.977	// Calibration multiplier applied to right side of drive-train.
#define SP_INTAKE	96		// Intake motor speed (out of a range of 0 to 127).
#define SP_BATTER	45		// Ball Batter arm deploy motor speed.

//=============================================================================
task main () {
	int joy_x, joy_y;		// Local joystick values read form system values.
	int leftRaw, rightRaw;	// Raw is used to calculate a desired speed.

	wait1Msec( 400 );		// Startup delay before entering the infinite loop.

	while( true ) {

		// Flip Sense of "front" of the robot.
		// --------------------------------------------------------------------------
		if ( vexRT[Btn6U] ) {
			if ( prevButtonState == false ) {
				prevButtonState = true;
				reverse = !reverse;
			}
		}
		else {
			prevButtonState = false;
		}


		// Motor Drive - Arcade
		// --------------------------------------------------------------------------
		joy_x = vexRT[Ch1];		// Get current joystick values.
		joy_y = vexRT[Ch3];

		leftRaw = 0;
		rightRaw = 0;

		if ( reverse ) {			// Reverse sense of "front" of robot.
			leftRaw =  LimitVal( MOTOR_MIN_VALUE, (((joy_x + joy_y))), MOTOR_MAX_VALUE );
			rightRaw = LimitVal( MOTOR_MIN_VALUE, (((joy_x - joy_y))), MOTOR_MAX_VALUE );
			SensorValue[ledREV] = 1;
			SensorValue[ledFWD] = 0;
		}
		else {						// Else, use "normal" sense of front of robot.
			leftRaw =  LimitVal( MOTOR_MIN_VALUE, (((joy_x - joy_y))), MOTOR_MAX_VALUE );
			rightRaw = LimitVal( MOTOR_MIN_VALUE, (((joy_x + joy_y))), MOTOR_MAX_VALUE );
			SensorValue[ledREV] = 0;
			SensorValue[ledFWD] = 1;
		}

		// acceleration tuning
		if( tmVal < time1[ timer1 ] ) {
			tmVal = time1[timer1] + TM_STEP;					// ReSchedule for future.

			if( leftSmooth < leftRaw ) leftSmooth += STEP;
			else if( leftSmooth > leftRaw ) leftSmooth -= STEP;
			else leftSmooth = leftRaw;

			if( rightSmooth < rightRaw ) rightSmooth += STEP;
			else if( rightSmooth > rightRaw ) rightSmooth -= STEP;
			else rightSmooth = rightRaw;
		}

		motor[LDrive1] = (int)(leftSmooth * SP_MULT);
		motor[LDrive2] =  (int)(leftSmooth * SP_MULT);

		motor[RDrive1] =  (int)(TURN_CAL * rightSmooth * SP_MULT);
		motor[RDrive2] =  (int)(TURN_CAL * rightSmooth * SP_MULT);


		// Pneumatic System Output Control
		// --------------------------------------------------------------------------
		if ( vexRT[Btn6UXmtr2] ) {
			SensorValue[PSIOUT1] = 0;
			clawActive = false;
		}
		if ( vexRT[Btn6DXmtr2] ) {
			SensorValue[PSIOUT1] = 1;
			clawActive = true;
		}

		// LED Strip on Claw Control
		// --------------------------------------------------------------------------
		//use pot value for testing
		int potValue = LimitVal(-127, SensorValue[sensorPotentiometer]/32, 127);
		if( clawActive ) {
			//SenSorValue[ledCLAW];
			motor[SigLight] = potValue;
		}
		else{
			SensorValue[ ledCLAW ] = 0;
			motor[SigLight] = 0;
		}

		/*if( clawActive ) {
		if( tmVal < time1[ timer1 ] ) {
		tmVal = time1[timer1] + 500;		// ReSchedule time value into the future.
		if( SensorValue[ ledCLAW ] )		// If the LEDs are on, turn them off.
		SensorValue[ ledCLAW ] = 0;
		else														// Else, turn them on.
		SensorValue[ ledCLAW ] = 1;
		}
		}
		else {															// Init LEDs and timer when claw is off.
		SensorValue[ ledCLAW ] = 0;
		tmVal = 0;
		}
		*/

		// Intake Motor
		// --------------------------------------------------------------------------
		if ( vexRT[Btn5UXmtr2] ) {
			motor[Intake] = -SP_INTAKE;
		}
		else if ( vexRT[Btn5DXmtr2] ) {
			motor[Intake] = SP_INTAKE;
		}
		else {
			motor[Intake] = 0;
		}

		// Ball Batter Arm
		// --------------------------------------------------------------------------
		if ( vexRT[Btn8UXmtr2] ){
			motor[BallBatter] = SP_BATTER;
		}
		else if ( vexRT[Btn8DXmtr2] ){
			motor[BallBatter] = -SP_BATTER;
		}
		else if ( abs(vexRT[Ch3Xmtr2]) > 5 ) {		// Else, use joystick if not in dead zone.
			motor[BallBatter] = vexRT[Ch3Xmtr2];	// Simply copy joystick value to motor.
		}
		else{
			motor[BallBatter] = 0;					// Else, set motor to zero speed.
		}

	} // while
} // main
