#pragma config(Sensor, dgtl1,  PSIOUT1,        sensorDigitalOut)
#pragma config(Sensor, dgtl6,  ledFWD,         sensorDigitalOut)
#pragma config(Sensor, dgtl7,  ledREV,         sensorDigitalOut)
#pragma config(Sensor, dgtl8,  ledCLAW,        sensorDigitalOut)
#pragma config(Motor,  port2,           LDrive1,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           LDrive2,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port4,           RDrive1,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           RDrive2,       tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           Intake,        tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           BallBatter,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port8,           SigLight,      tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// ============================================================================
//	OCCRA Trash Can Rush	Fall 2017 Season
//
//	Last Updated 10/24/2017
//
// ============================================================================

bool prevButtonState = false;
bool reverse = true;
bool clawActive = false;
long tmVal = 0;
int compLeft=0, compRight=0;


// Macros ---------------------------------------------------------------------

#define MOTOR_MAX_VALUE			127
#define MOTOR_MIN_VALUE			(-127)

#define LIGHT_LED 					127
#define LIGHT_ORANGE 				(-127)
#define LIGHT_OFF 					0

#define max( A, B )				A > B ? A : B
#define min( A, B )				A < B ? A : B
#define LimitVal( L, T, H )		max( min( T, H ), L)

#define SP_MULT             0.55
#define STEP								2					// Motor counts to step.
#define TM_STEP							10				// Time (in milliseconds) between steps.

//=============================================================================
task main () {

	wait1Msec(400);
	setBaudRate(UART0, baudRate115200 );
	while (true) {

		// Flip Functionality
		// --------------------------------------------------------------------------
		if (vexRT[Btn6U]) {
			if (prevButtonState == false) {
				prevButtonState = true;
				reverse = !reverse;
			}
		}
		else {
			prevButtonState = false;
		}
		// Scaling factor for flip


		// Motor Drive - Arcade
		// --------------------------------------------------------------------------
		int joy_x = vexRT[Ch1];
		int joy_y = vexRT[Ch3];

		int leftVal = 0;
		int rightVal = 0;

		if (reverse) {
			leftVal = LimitVal(MOTOR_MIN_VALUE, (((joy_x + joy_y)
			)), MOTOR_MAX_VALUE);
			rightVal = LimitVal(MOTOR_MIN_VALUE, (((joy_x - joy_y))), MOTOR_MAX_VALUE);
			SensorValue[ledREV] = 1;
			SensorValue[ledFWD] = 0;
		}
		else {
			leftVal = LimitVal( MOTOR_MIN_VALUE , (((joy_x - joy_y))), MOTOR_MAX_VALUE );
			rightVal = LimitVal( MOTOR_MIN_VALUE    , (((joy_x + joy_y))), MOTOR_MAX_VALUE );
			SensorValue[ledREV] = 0;
			SensorValue[ledFWD] = 1;
		}

		if( tmVal < time1[ timer1 ] ) {
				tmVal = time1[timer1] + TM_STEP;
				if( compLeft < leftVal ) compLeft += STEP;
				else if( compLeft > leftVal ) compLeft -= STEP;
				else compLeft = leftVal;

				if( compRight < rightVal ) compRight += STEP;
				if( compRight > rightVal ) compRight -= STEP;
		}

		motor[LDrive1] = (int)(compLeft * SP_MULT);
		motor[LDrive2] =  (int)(compLeft * SP_MULT);

		motor[RDrive1] =  (int)(0.977 * compRight * SP_MULT);
		motor[RDrive2] =  (int) (0.977 * compRight * SP_MULT);


		// Pneumatic System Output Control
		// --------------------------------------------------------------------------
		if (vexRT[Btn6UXmtr2]) {
			SensorValue[PSIOUT1] = 0;
			clawActive = false;
		}
		if (vexRT[Btn6DXmtr2]) {
			SensorValue[PSIOUT1] = 1;
			clawActive = true;
		}

		// LED Strip on Claw Control
		// --------------------------------------------------------------------------

		if(clawActive){
			SensorValue[ ledCLAW ] = 1;
		}
		else{
			SensorValue[ ledCLAW ] = 0;
		}

		/*if( clawActive ) {
			if( tmVal < time1[ timer1 ] ) {
				tmVal = time1[timer1] + 500;		// ReSchedule time value into the future.
				if( SensorValue[ ledCLAW ] )		// If the LEDs are on, turn them off.
					SensorValue[ ledCLAW ] = 0;
				else														// Else, turn them on.
					SensorValue[ ledCLAW ] = 1;
			}
		}
		else {															// Init LEDs and timer when claw is off.
				SensorValue[ ledCLAW ] = 0;
				tmVal = 0;
		}
		*/

		// Intake Motor
		// --------------------------------------------------------------------------
		if (vexRT[Btn5UXmtr2]) {
			motor[Intake] = -96;
		}
		else if (vexRT[Btn5DXmtr2]) {
			motor[Intake] = 96;
		}
		else {
			motor[Intake] = 0;
		}

		// Ball Batter Arm
		// --------------------------------------------------------------------------
		if (vexRT[Btn8UXmtr2]){
			motor[BallBatter] = 45;
		}
		else if ( vexRT[Btn8DXmtr2] ){
			motor[BallBatter] = -45;
		}
		else if (abs(vexRT[Ch3Xmtr2]) > 5 ){					// On joystick,
			motor[BallBatter] = vexRT[Ch3Xmtr2];
		}
		else{
			motor[BallBatter] = 0;
		}

	} // while
} // main
